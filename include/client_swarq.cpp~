#ifndef CLIENT_SWARQ_HPP
#define CLIENT_SWARQ_HPP

#include <cstdlib>
#include <iostream>
#include <string>

#include <boost/asio/deadline_timer.hpp>
#include <boost/asio/io_service.hpp>
#include <boost/asio/ip/udp.hpp>
#include <boost/bind.hpp>
#include <boost/date_time/posix_time/posix_time_types.hpp>

#include "frame.hpp"
#include "file_reader.hpp"

class client_swarq{
public:
  client_swarq(boost::asio::io_service & io_service, const std::string & server, 
	       const std::string & port, boost::posix_time::seconds t) 
    : io_service(io_service), socket(io_service), timer(io_service), timeout(t){

    boost::asio::ip::udp::resolver resolver(io_service);
    boost::asio::ip::udp::resolver::query query(boost::asio::ip::udp::v4(), server,
				      port);

    server_endpoint = *resolver.resolve(query);

    socket.open(boost::asio::ip::udp::v4());
  }
    
  std::size_t send_to(const Frame & frame){
    boost::system::error_code ec;
    char buffer[max_length];
    char recv_buffer[max_length];
    size_t buffer_size;
    std::string s;
    size_t length = 0;

    
    buffer_size = frame.serialize(buffer);    
    
    do{
      socket.send_to(boost::asio::buffer(buffer, buffer_size), 
		     server_endpoint, 0, ec);
    
      timer.expires_from_now(timeout);
      timer.async_wait(boost::bind(&client_swarq::check_deadline, this, &ec));
 
      ec = boost::asio::error::would_block;

      length = 0;
      socket.async_receive(boost::asio::buffer(recv_buffer, max_length),
			   boost::bind(&client_swarq::handle_receive, _1, _2, &ec, &length));
    
      do 
	io_service.run_one(); 
      while (ec == boost::asio::error::would_block);

    }while(ec == boost::asio::error::interrupted);
    timer.expires_at(boost::posix_time::pos_infin);
    
    Frame recv_frame(recv_buffer, length);
    
	std::cout << recv_frame.get_num() << " " << recv_frame.get_data() << std::endl;
    /*
	s = recv_frame.get_data();
	}while(s != "ACK");
    */
    return length;
  }


private:
  void check_deadline(boost::system::error_code * ec){
    if (timer.expires_at() <= boost::asio::deadline_timer::traits_type::now()){
      //socket.cancel();
      //std::cout << "timeout" << std::endl;
      *ec = boost::asio::error::interrupted;
      timer.expires_at(boost::posix_time::pos_infin);
    }
  }

  static void handle_receive(const boost::system::error_code& ec, std::size_t length,
			     boost::system::error_code* out_ec, std::size_t* out_length){
    *out_ec = ec;
    *out_length = length;
  }
    
  boost::asio::ip::udp::endpoint server_endpoint;
  boost::asio::io_service & io_service;
  boost::asio::ip::udp::socket socket;
  boost::asio::deadline_timer timer;
  boost::posix_time::time_duration timeout;
  static const size_t max_length = 1024;
  
};


int main(int argc, char ** argv){
  boost::asio::io_service io_service;

  client_swarq c(io_service, argv[1], argv[2], 
		 boost::posix_time::seconds(1));

  std::string fileout = "file_out.txt";
  std::string filein = "file_in.txt";

  const unsigned buffer_size = 1;

  Frame frame_file_name(0, fileout.c_str(), fileout.size()+1);
  c.send_to(frame_file_name);

  file_reader freader("file_in.txt");

  char * buffer = new char [buffer_size+1];

  uint32_t cnt = 0;

  std::cout << "ok" << std::endl;

  while(!freader.file_ended()){
    
    std::cout << "ok" << std::endl;
    
    size_t len = freader.read_next_bytes(buffer, buffer_size);
    
    std::cout << len << " "<< cnt << buffer << std::endl;
    
    Frame frame_file_bytes(cnt, buffer, len);

    cnt = cnt + 1;
    c.send_to(frame_file_bytes);
  }

   std::cout << "oksaas" << std::endl;

  Frame frame_stop("", 0);
  c.send_to(frame_stop);
  
}

#endif // CLIENT_SWARQ_HPP
